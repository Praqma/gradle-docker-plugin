plugins { id 'com.jfrog.bintray' version '0.6' }

apply plugin: 'eclipse'
apply plugin: 'groovy'
apply plugin: 'maven-publish'
apply plugin: 'com.jfrog.bintray'

repositories {  jcenter()  }

targetCompatibility = sourceCompatibility = '1.7'

group = 'net.praqma.gradle'
version = '0.2'
description = 'Gradle plugin to orchestrate Docker containers'

ext {
	pluginId = 'net.praqma.docker'
	artifact = 'gradle-docker-plugin'
	github = 'https://github.com/Praqma/gradle-custom-dist-plugin'
}

dependencies {
	compile gradleApi()
	compile localGroovy()

	compile 'com.github.docker-java:docker-java:0.10.3'
	//compile ('com.github.docker-java:docker-java:0.10.4-SNAPSHOT')

	testCompile 'com.google.guava:guava:18+'
	testCompile 'junit:junit:4.11'
	testCompile 'org.hamcrest:hamcrest-library:1.3'
}

test {
	// When executing test bouncy castle from gradle is different signature than bouncy castle from java-dockker
	// so remove it.
	classpath = classpath.filter { File f ->
		!f.name.equals('bcprov-jdk15-1.46.jar')
	}
	dependsOn testClasses
}

task sourceJar(type: Jar) {
	classifier 'sources'
	from sourceSets.main.allSource
}

publishing {
	publications {
		plugin(MavenPublication) {
			artifactId artifact

			from components.java
			artifact sourceJar

			pom.withXml {
				asNode().appendNode('description', project.description)
			}
		}
	}
}

bintray {
	// E.g. defined in gradle.properties
	user = project.bintrayUser
	key = project.bintrayApiKey

	publications = ['plugin']
	dryRun = false //Whether to run this as dry-run, without deploying
	publish = true //If version should be auto published after an upload
	pkg {
		repo = 'gradle-plugins'
		userOrg = 'praqma'
		name = artifact
		desc = project.description
		websiteUrl = github
		vcsUrl = "${project.github}.git"
		licenses = ['Apache-2.0']
		publicDownloadNumbers = true
		//Optional version descriptor
		version {
			attributes = ['gradle-plugin': "${pluginId}:${group}:${artifact}"]
		}
	}
}

/*
 eclipse.classpath.file {
 whenMerged { Classpath cp ->
 String gradleHome = gradle.getGradleHomeDir().absolutePath
 FileReferenceFactory fileRefFactory = new FileReferenceFactory()
 String gradleSrc = "${gradleHome}/src" // src doesn't exists for binary gradle distributions
 assert new File(gradleSrc).exists()
 cp.entries.findAll{  it instanceof Library && it.sourcePath == null}.each{ Library lib ->
 File jarFile = new File(lib.path)
 if (jarFile.path.startsWith(gradleHome)){
 switch (jarFile.name) {
 case { it.startsWith("gradle-") }:
 lib.sourcePath = fileRefFactory.fromPath(gradleSrc)
 break
 case "groovy-all-${GroovySystem.version}.jar":
 def componentIds = configurations.groovy.incoming.resolutionResult.allDependencies.collect { it.selected.id }
 def result = dependencies.createArtifactResolutionQuery()
 .forComponents(componentIds)
 .withArtifacts(JvmLibrary, SourcesArtifact)
 .execute()
 def resolvedComponent = singleElement(result.resolvedComponents)
 def src = singleElement(resolvedComponent.getArtifacts(SourcesArtifact)).file
 lib.sourcePath = fileRefFactory.fromFile(src)
 break
 }
 }
 }
 }
 }
 def singleElement(Iterable collection) {
 def iter = collection.iterator()
 def answer = iter.next()
 assert !iter.hasNext()
 answer
 }
 */
